<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rolling Ballz</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <!-- Combined Three.js import into the main script block -->
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            /* Make body fill the entire viewport */
            width: 100vw;
            height: 100vh;
        }
        canvas {
            display: block;
            background-color: #87CEEB;
            /* Make canvas fill its parent (body) */
            width: 100%;
            height: 100%;
        }
        #coordinatesDisplay {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 8px;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            z-index: 100;
            display: none; /* Hidden by default, still controlled by 'z' key */
        }
        #cameraControlPanel {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }
        #cameraModeDisplay {
            background-color: rgba(30, 144, 255, 0.7);
            color: white;
            padding: 10px;
            border-radius: 8px;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            user-select: none;
        }
        #toggleCameraButton {
            background-color: rgba(255, 140, 0, 0.8); /* Dark Orange */
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            transition: background-color 0.1s, transform 0.1s;
        }
        #toggleCameraButton:hover {
            background-color: rgba(255, 165, 0, 0.9);
        }
        #toggleCameraButton:active {
            transform: translateY(1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        /* --- Mobile Control Styles --- */
        #mobileControls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            pointer-events: none; /* Allows clicks/touches to fall through to the canvas by default */
            z-index: 200;
        }

        #dpad, #actionButtons {
            display: flex;
            gap: 10px;
            pointer-events: all; /* Make controls interactive */
        }

        #dpad {
            flex-direction: column;
            width: 150px; /* Base for the whole D-pad area */
            margin-left: 20px;
            margin-bottom: 20px;
        }

        #actionButtons {
            flex-direction: column;
            margin-right: 20px;
            margin-bottom: 20px;
        }

        .dpad-row {
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        .control-button {
            width: 50px;
            height: 50px;
            background-color: rgba(50, 50, 50, 0.8);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 18px;
            font-weight: bold;
            user-select: none;
            cursor: pointer;
            transition: background-color 0.1s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            touch-action: manipulation; /* Important for preventing double-tap zoom/scroll */
        }

        .control-button:active {
            background-color: rgba(100, 100, 100, 0.9);
            box-shadow: none;
            transform: translateY(2px);
        }

        /* Styling specific action buttons */
        #btnJump { background-color: rgba(30, 144, 255, 0.8); } /* Dodger Blue */
        #btnExplode { background-color: rgba(255, 69, 0, 0.8); } /* Orange Red */
        #btnResetSize { background-color: rgba(50, 205, 50, 0.8); } /* Lime Green */

        /* Override size for Jump button to be larger target */
        #btnJump {
             width: 65px;
             height: 65px;
             border-radius: 12px;
             font-size: 20px;
             margin-top: 15px; /* Push it down slightly from the top edge */
        }

        /* Touch area for camera rotation */
        #cameraControlArea {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 150; /* Above canvas, below controls */
            pointer-events: auto; /* Allow touch on the background */
        }
    </style>
</head>
<body>
    <div id="coordinatesDisplay">
        Coordinates:<br>
        X: <span id="coordX">0.00</span><br>
        Y: <span id="coordY">0.00</span><br>
        Z: <span id="coordZ">0.00</span>
    </div>

    <div id="cameraControlPanel">
        <button id="toggleCameraButton">Toggle Camera</button>
        <div id="cameraModeDisplay">
            Mode: <span id="modeText">POV</span> (P key)
        </div>
    </div>

    <!-- Mobile Controls Overlay -->
    <div id="cameraControlArea"></div>

    <div id="mobileControls">
        <!-- Directional Pad (D-pad) -->
        <div id="dpad">
            <div class="dpad-row">
                <!-- Up Button (W) -->
                <div id="btnUp" class="control-button" data-key="w">▲</div>
            </div>
            <div class="dpad-row">
                <!-- Left Button (A) -->
                <div id="btnLeft" class="control-button" data-key="a">◀</div>
                <div style="width: 50px; height: 50px;"></div> <!-- Spacer -->
                <!-- Right Button (D) -->
                <div id="btnRight" class="control-button" data-key="d">▶</div>
            </div>
            <div class="dpad-row">
                <!-- Down Button (S) -->
                <div id="btnDown" class="control-button" data-key="s">▼</div>
            </div>
        </div>

        <!-- Action Buttons -->
        <div id="actionButtons">
            <!-- Jump Button (Space) -->
            <div id="btnJump" class="control-button">JUMP</div>
            <!-- Explode Button (B) -->
            <div id="btnExplode" class="control-button">EXP</div>
            <!-- Reset Size Button (V) -->
            <div id="btnResetSize" class="control-button">SIZE</div>
        </div>
    </div>

    <!-- The main game logic script -->
    <script type="module">
        // Import THREE directly into this script block
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js';

        // Basic Three.js setup
        let scene, camera, renderer;
        let physicsWorld; // Cannon.js world
        const timeStep = 1 / 60; // seconds

        // Game objects (Three.js Mesh and Cannon.js Body)
        let ballMesh;
        let fieldBody;
        let ballBody;

        // Keyboard and Mobile input state
        const keys = {};
        const baseBallControlSpeed = 15;
        const sprintSpeedMultiplier = 2;
        let currentBallControlSpeed = baseBallControlSpeed;

        // --- Camera State Variables ---
        let isFreeCamera = false;
        const freeCamSpeed = 0.5;
        let cameraAngle = 0; // Yaw (Left/Right rotation)
        let cameraPitch = -Math.PI / 8; // Pitch (Up/Down rotation)
        const maxPitch = Math.PI / 2.5; // Limit vertical look
        // -----------------------------

        // Define sizes globally
        let ballRadius = 1.5;
        const defaultBallRadius = 1.5;
        const fieldWidth = 100;
        const fieldLength = 150;
        const jumpForce = 40;

        // Camera POV variables
        const mouseSensitivity = 0.005;
        const touchSensitivity = 0.015;
        const cameraDistance = 15;
        const cameraHeight = 10;
        const cameraLookAhead = 5;

        // Mouse/Touch control variables
        let isRightMouseDown = false;
        let isTouchDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0; // Added for free camera pitch control
        let lastTouchX = 0;
        let lastTouchY = 0; // Added for free camera pitch control

        // Ground tile variables
        const groundTiles = [];
        const numTilesX = 5;
        const numTilesZ = 5;

        // Particle system array
        const explosionParticleSystems = [];

        // UI elements
        let coordinatesDisplay;
        let coordXSpan, coordYSpan, coordZSpan;
        let cameraModeDisplay, modeTextSpan;
        let toggleCameraButton;

        // Function to create a texture with text on it
        function createBallTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const context = canvas.getContext('2d');

            context.fillStyle = '#000000';
            context.fillRect(0, 0, canvas.width, canvas.height);

            context.font = 'bold 60px Arial';
            context.fillStyle = '#FFFFFF';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText('BALL!', canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.NearestFilter;
            texture.magFilter = THREE.NearestFilter;
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(1, 1);
            return texture;
        }

        // Function to create/recreate the ball mesh and physics body
        function createBall(radius) {
            // Remove old ball if it exists
            if (ballMesh) {
                scene.remove(ballMesh);
                ballMesh.geometry.dispose();
                ballMesh.material.dispose();
            }
            if (ballBody) {
                physicsWorld.removeBody(ballBody);
            }

            // Create Ball Mesh
            const ballGeometry = new THREE.SphereGeometry(radius, 32, 32);
            const ballTexture = createBallTexture();
            const ballMaterialThree = new THREE.MeshStandardMaterial({
                map: ballTexture,
                color: 0xFFFFFF
            });
            ballMesh = new THREE.Mesh(ballGeometry, ballMaterialThree);
            ballMesh.castShadow = true;
            ballMesh.receiveShadow = true;
            scene.add(ballMesh);

            // Create Ball Physics Body
            const ballShape = new CANNON.Sphere(radius);
            const ballCannonMaterial = new CANNON.Material("ballMaterial");
            ballBody = new CANNON.Body({ mass: 1, material: ballCannonMaterial });
            ballBody.addShape(ballShape);
            ballBody.linearDamping = 0.1;
            ballBody.angularDamping = 0.1;
            physicsWorld.addBody(ballBody);

            // Ensure the ball starts at a valid position after recreation
            ballBody.position.set(ballMesh.position.x, radius, ballMesh.position.z);
            ballBody.velocity.set(0, 0, 0);
            ballBody.angularVelocity.set(0, 0, 0);
        }

        /**
         * Toggles between POV and Free Camera modes.
         */
        function toggleCameraMode() {
            isFreeCamera = !isFreeCamera;
            modeTextSpan.textContent = isFreeCamera ? 'FREE' : 'POV';
        }

        // --- Initialization ---
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue

            // Camera setup (initial position, will be updated in animate)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, cameraHeight, cameraDistance);
            camera.lookAt(0, 0, 0);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // Enable shadows
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Physics World (Cannon.js)
            physicsWorld = new CANNON.World();
            physicsWorld.gravity.set(0, -9.82, 0);
            physicsWorld.broadphase = new CANNON.SAPBroadphase(physicsWorld);

            // Materials for physics world
            const groundMaterial = new CANNON.Material("groundMaterial");
            const ballMaterial = new CANNON.Material("ballMaterial");

            const groundBallContactMaterial = new CANNON.ContactMaterial(
                groundMaterial, ballMaterial, { friction: 0.8, restitution: 0.6 }
            );
            physicsWorld.addContactMaterial(groundBallContactMaterial);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(20, 40, 30);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 200;
            directionalLight.shadow.camera.left = -fieldWidth / 2 * numTilesX / 2;
            directionalLight.shadow.camera.right = fieldWidth / 2 * numTilesX / 2;
            directionalLight.shadow.camera.top = fieldLength / 2 * numTilesZ / 2;
            directionalLight.shadow.camera.bottom = -fieldLength / 2 * numTilesZ / 2;
            scene.add(directionalLight);

            // --- Create multiple ground planes for the infinite visual effect with texture ---
            const textureLoader = new THREE.TextureLoader();
            const grassTexture = textureLoader.load(
                'https://placehold.co/128x128/558B2F/ffffff/png?text=Grass',
                undefined,
                undefined,
                (error) => {
                    console.error('An error occurred loading the grass texture:', error);
                    fieldMaterial.map = null;
                    fieldMaterial.color.set(0x558B2F);
                    fieldMaterial.needsUpdate = true;
                }
            );

            // Set texture to repeat
            grassTexture.wrapS = THREE.RepeatWrapping;
            grassTexture.wrapT = THREE.RepeatWrapping;
            grassTexture.repeat.set(fieldWidth / 10, fieldLength / 10);

            const fieldGeometry = new THREE.PlaneGeometry(fieldWidth, fieldLength);
            const fieldMaterial = new THREE.MeshStandardMaterial({
                map: grassTexture,
                color: 0x558B2F
            });

            for (let i = 0; i < numTilesX * numTilesZ; i++) {
                const tile = new THREE.Mesh(fieldGeometry, fieldMaterial);
                tile.rotation.x = -Math.PI / 2;
                tile.receiveShadow = true;
                scene.add(tile);
                groundTiles.push(tile);
            }

            // Physics body for the ground
            const groundShape = new CANNON.Plane();
            fieldBody = new CANNON.Body({ mass: 0, material: groundMaterial });
            fieldBody.addShape(groundShape);
            fieldBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            physicsWorld.addBody(fieldBody);

            // Create the initial ball
            createBall(ballRadius);

            // Initial position of the ball
            resetGame();

            // Get UI elements
            coordinatesDisplay = document.getElementById('coordinatesDisplay');
            coordXSpan = document.getElementById('coordX');
            coordYSpan = document.getElementById('coordY');
            coordZSpan = document.getElementById('coordZ');
            cameraModeDisplay = document.getElementById('cameraModeDisplay');
            modeTextSpan = document.getElementById('modeText');
            toggleCameraButton = document.getElementById('toggleCameraButton');

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            // Mouse event listeners (for desktop control)
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());

            // Add listener for the new button
            toggleCameraButton.addEventListener('click', toggleCameraMode);

            // --- Touch/Mobile Control Listeners ---
            const cameraControlArea = document.getElementById('cameraControlArea');
            cameraControlArea.addEventListener('touchstart', onTouchStart, { passive: true });
            cameraControlArea.addEventListener('touchmove', onTouchMove, { passive: true });
            cameraControlArea.addEventListener('touchend', onTouchEnd);

            // Map D-pad buttons to the 'keys' object
            document.querySelectorAll('#dpad .control-button').forEach(button => {
                const keyName = button.getAttribute('data-key');
                button.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    keys[keyName] = true;
                });
                button.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    keys[keyName] = false;
                });
                button.addEventListener('mousedown', () => keys[keyName] = true);
                button.addEventListener('mouseup', () => keys[keyName] = false);
                button.addEventListener('mouseleave', () => keys[keyName] = false);
            });

            // Map Action buttons to their functions
            document.getElementById('btnJump').addEventListener('click', () => {
                if (!isFreeCamera && ballBody.position.y <= ballRadius + 0.1) {
                    ballBody.applyImpulse(new CANNON.Vec3(0, jumpForce, 0), ballBody.position);
                }
            });
            document.getElementById('btnExplode').addEventListener('click', explodeBall);
            document.getElementById('btnResetSize').addEventListener('click', resetBallSize);
        }

        // --- Game Logic ---

        function updatePhysics() {
            // Only update physics if NOT in free camera mode, so the ball can be controlled
            // or if the ball is still in the air after the free camera was engaged
            if (!isFreeCamera) {
                physicsWorld.step(timeStep);

                // Synchronize Three.js meshes with Cannon.js bodies
                ballMesh.position.copy(ballBody.position);
                ballMesh.quaternion.copy(ballBody.quaternion);

                // --- Wrap-around logic for the ball (physics position) ---
                if (ballBody.position.x > fieldWidth / 2) {
                    ballBody.position.x = -fieldWidth / 2;
                } else if (ballBody.position.x < -fieldWidth / 2) {
                    ballBody.position.x = fieldWidth / 2;
                }

                if (ballBody.position.z > fieldLength / 2) {
                    ballBody.position.z = -fieldLength / 2;
                } else if (ballBody.position.z < -fieldLength / 2) {
                    ballBody.position.z = fieldLength / 2;
                }
                // --- End Wrap-around logic ---

                // Ball movement input (direct control based on camera's current direction)
                let ballTargetVelocity = new CANNON.Vec3(0, 0, 0);
                // Calculate forward and right vectors relative to the current camera angle (Yaw)
                const forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraAngle);
                const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraAngle);

                // Movement is only applied to the ball in POV mode
                if (keys['ArrowUp'] || keys['w']) {
                    ballTargetVelocity.x += forward.x * currentBallControlSpeed;
                    ballTargetVelocity.z += forward.z * currentBallControlSpeed;
                }
                if (keys['ArrowDown'] || keys['s']) {
                    ballTargetVelocity.x -= forward.x * currentBallControlSpeed;
                    ballTargetVelocity.z -= forward.z * currentBallControlSpeed;
                }
                if (keys['ArrowLeft'] || keys['a']) {
                    ballTargetVelocity.x -= right.x * currentBallControlSpeed;
                    ballTargetVelocity.z -= right.z * currentBallControlSpeed;
                }
                if (keys['ArrowRight'] || keys['d']) {
                    ballTargetVelocity.x += right.x * currentBallControlSpeed;
                    ballTargetVelocity.z += right.z * currentBallControlSpeed;
                }

                // Apply force to move the ball towards the target velocity
                ballBody.velocity.x = ballTargetVelocity.x;
                ballBody.velocity.z = ballTargetVelocity.z;
            } else {
                 // Keep updating ball mesh position even in free-cam if physics is paused for the ball
                if (ballBody) {
                    ballBody.wakeUp(); // Keep physics body active in case it was sleeping
                }
                // You could optionally pause physics entirely here if the free camera is completely static
                // but keeping it running allows the ball to settle if you switch back.
            }
        }

        function resetGame() {
            // Reset ball position and velocity
            ballBody.position.set(0, ballRadius, 0);
            ballBody.velocity.set(0, 0, 0);
            ballBody.angularVelocity.set(0, 0, 0);
            ballMesh.visible = true;
        }

        // Function to create and animate explosion particles
        function createExplosionParticles(position) {
            const numParticles = 100;
            const particleGeometry = new THREE.BufferGeometry();
            const positions = [];
            const velocities = [];
            const lifetimes = [];
            const initialColors = [];

            const maxLifetime = 1.0; // seconds
            const maxSpeed = 10;

            for (let i = 0; i < numParticles; i++) {
                // Position (starting from the ball's position)
                positions.push(position.x, position.y, position.z);

                // Velocity (random direction outwards)
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * maxSpeed;
                velocities.push(
                    Math.cos(angle) * speed, // X velocity
                    Math.random() * speed, // Y velocity (upwards bias for explosion)
                    Math.sin(angle) * speed  // Z velocity
                );

                // Lifetime for each particle
                lifetimes.push(Math.random() * maxLifetime);

                // Colors (orange to yellow)
                const color = new THREE.Color(0xFF4500); // OrangeRed
                color.lerp(new THREE.Color(0xFFFF00), Math.random()); // Blend with yellow
                initialColors.push(color.r, color.g, color.b);
            }

            particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            particleGeometry.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3));
            particleGeometry.setAttribute('lifetime', new THREE.Float32BufferAttribute(lifetimes, 1));
            particleGeometry.setAttribute('initialColor', new THREE.Float32BufferAttribute(initialColors, 3));
            // Initialize the color attribute that will be updated in the loop
            particleGeometry.setAttribute('color', new THREE.Float32BufferAttribute(initialColors.slice(), 3));


            const particleMaterial = new THREE.PointsMaterial({
                size: 0.8,
                vertexColors: true,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
            explosionParticleSystems.push({
                mesh: particles,
                startTime: performance.now(),
                maxLifetime: maxLifetime * 1000 // Convert to milliseconds
            });
        }


        // Function to make the ball "explode" and respawn
        function explodeBall() {
            if (ballMesh && ballBody) {
                createExplosionParticles(ballMesh.position);

                ballMesh.visible = false;
                physicsWorld.removeBody(ballBody);

                setTimeout(() => {
                    createBall(ballRadius);
                    resetGame();
                }, 500);
            }
        }

        // Function to teleport the ball to a random location
        function teleportBall() {
            const randomX = (Math.random() * fieldWidth) - (fieldWidth / 2);
            const randomZ = (Math.random() * fieldLength) - (fieldLength / 2);

            ballBody.position.set(randomX, ballRadius, randomZ);
            ballBody.velocity.set(0, 0, 0);
            ballBody.angularVelocity.set(0, 0, 0);
        }

        // Function to make the ball bigger
        function makeBallBigger() {
            ballRadius *= 1.5;
            createBall(ballRadius);
            teleportBall();
        }

        // Function to reset ball to default size
        function resetBallSize() {
            ballRadius = defaultBallRadius;
            createBall(ballRadius);
            teleportBall();
        }

        // --- Event Handlers ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(event) {
            keys[event.key] = true;

            // Toggle Free Camera mode when 'p' is pressed
            if (event.key === 'p') {
                toggleCameraMode();
            }

            // Enable sprint when Shift is pressed (for both ball and camera movement)
            if (event.key === 'Shift') {
                currentBallControlSpeed = baseBallControlSpeed * sprintSpeedMultiplier;
            }

            // Jumping feature with Spacebar (only in POV mode)
            if (!isFreeCamera && event.key === ' ' && ballBody.position.y <= ballRadius + 0.1) {
                ballBody.applyImpulse(new CANNON.Vec3(0, jumpForce, 0), ballBody.position);
            }
            // Other controls (b, t, c, v, r, z) remain the same
            if (event.key === 'b') { explodeBall(); }
            if (event.key === 't') { teleportBall(); }
            if (event.key === 'c') { makeBallBigger(); }
            if (event.key === 'v') { resetBallSize(); }
            if (event.key === 'r') { resetGame(); }
            if (event.key === 'z') {
                if (coordinatesDisplay.style.display === 'none' || coordinatesDisplay.style.display === '') {
                    coordinatesDisplay.style.display = 'block';
                } else {
                    coordinatesDisplay.style.display = 'none';
                }
            }
        }

        function onKeyUp(event) {
            keys[event.key] = false;
            // Disable sprint when Shift is released
            if (event.key === 'Shift') {
                currentBallControlSpeed = baseBallControlSpeed;
            }
        }

        function onMouseDown(event) {
            // Right-click button is 2
            if (event.button === 2) {
                isRightMouseDown = true;
                lastMouseX = event.clientX; // Store initial mouse X position
                lastMouseY = event.clientY; // Store initial mouse Y position
            }
        }

        function onMouseUp(event) {
            if (event.button === 2) {
                isRightMouseDown = false;
            }
        }

        function onMouseMove(event) {
            if (isRightMouseDown) {
                const deltaX = event.clientX - lastMouseX;
                const deltaY = event.clientY - lastMouseY;

                // Update Yaw (horizontal rotation)
                cameraAngle -= deltaX * mouseSensitivity;

                // Update Pitch (vertical rotation)
                // Note: deltaY is inverted for intuitive mouse control
                cameraPitch -= deltaY * mouseSensitivity;
                // Clamp pitch to prevent flipping the camera
                cameraPitch = Math.max(-maxPitch, Math.min(maxPitch, cameraPitch));

                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
            }
        }

        // --- Mobile Touch Handlers for Camera Rotation ---

        function onTouchStart(event) {
            // Only consider the first touch for camera rotation
            if (event.touches.length === 1 && event.target.id === 'cameraControlArea') {
                isTouchDragging = true;
                lastTouchX = event.touches[0].clientX;
                lastTouchY = event.touches[0].clientY;
            }
        }

        function onTouchMove(event) {
            if (isTouchDragging) {
                const currentTouchX = event.touches[0].clientX;
                const currentTouchY = event.touches[0].clientY;

                const deltaX = currentTouchX - lastTouchX;
                const deltaY = currentTouchY - lastTouchY;

                // Use a higher touch sensitivity
                cameraAngle -= deltaX * touchSensitivity;
                cameraPitch -= deltaY * touchSensitivity;

                cameraPitch = Math.max(-maxPitch, Math.min(maxPitch, cameraPitch));

                lastTouchX = currentTouchX;
                lastTouchY = currentTouchY;
            }
        }

        function onTouchEnd() {
            isTouchDragging = false;
        }


        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            updatePhysics();

            // --- Update ground tiles position for infinite visual effect ---
            const centerObject = isFreeCamera ? camera : ballMesh;
            const centerObjectX = centerObject.position.x;
            const centerObjectZ = centerObject.position.z;

            let tileIndex = 0;
            for (let i = -Math.floor(numTilesX / 2); i <= Math.floor(numTilesX / 2); i++) {
                for (let j = -Math.floor(numTilesZ / 2); j <= Math.floor(numTilesZ / 2); j++) {
                    const tile = groundTiles[tileIndex];

                    // Center the grid around the camera/ball
                    tile.position.x = Math.floor(centerObjectX / fieldWidth) * fieldWidth + (i * fieldWidth);
                    tile.position.z = Math.floor(centerObjectZ / fieldLength) * fieldLength + (j * fieldLength);

                    tile.position.y = 0;

                    tileIndex++;
                }
            }

            // --- Update explosion particles ---
            const currentTime = performance.now();
            for (let i = explosionParticleSystems.length - 1; i >= 0; i--) {
                const particleSystem = explosionParticleSystems[i];
                const elapsed = currentTime - particleSystem.startTime;

                if (elapsed > particleSystem.maxLifetime) {
                    scene.remove(particleSystem.mesh);
                    particleSystem.mesh.geometry.dispose();
                    particleSystem.mesh.material.dispose();
                    explosionParticleSystems.splice(i, 1);
                } else {
                    const geometry = particleSystem.mesh.geometry;
                    const positions = geometry.attributes.position.array;
                    const velocities = geometry.attributes.velocity.array;
                    const lifetimes = geometry.attributes.lifetime.array;
                    const initialColors = geometry.attributes.initialColor.array;
                    const currentColors = geometry.attributes.color.array; // Get the mutable color array

                    const normalizedTime = elapsed / particleSystem.maxLifetime;
                    const opacity = 1 - normalizedTime;

                    for (let j = 0; j < positions.length; j += 3) {
                        const particleIndex = j / 3;
                        const particleLifetime = lifetimes[particleIndex] * 1000;

                        if (elapsed < particleLifetime) {
                            positions[j] += velocities[j] * timeStep;
                            positions[j + 1] += velocities[j + 1] * timeStep;
                            positions[j + 2] += velocities[j + 2] * timeStep;

                            velocities[j+1] -= 9.82 * timeStep; // Simple gravity

                            // Fade out individual particle color
                            const r = initialColors[j];
                            const g = initialColors[j + 1];
                            const b = initialColors[j + 2];

                            // Simple linear fade towards black
                            const fadeFactor = 1.0 - (elapsed / particleLifetime);

                            currentColors[j] = r * fadeFactor;
                            currentColors[j + 1] = g * fadeFactor;
                            currentColors[j + 2] = b * fadeFactor;
                        }
                    }
                    geometry.attributes.position.needsUpdate = true;
                    geometry.attributes.color.needsUpdate = true;
                    particleSystem.mesh.material.opacity = opacity;
                }
            }


            // --- Camera Positioning Logic ---
            if (isFreeCamera) {
                // FREE CAMERA MODE
                const camPos = camera.position;
                const currentCamSpeed = keys['Shift'] ? freeCamSpeed * 3 : freeCamSpeed; // Faster speed with Shift

                // Calculate the camera's forward and right vectors based on current Yaw (cameraAngle)
                // Use the camera's full rotation for direction (YXZ order is common for FPS-style controls)
                const rotation = new THREE.Euler(cameraPitch, cameraAngle, 0, 'YXZ');
                camera.quaternion.setFromEuler(rotation);

                // Get the direction vectors from the camera's world matrix
                const matrix = camera.matrixWorld;
                const forward = new THREE.Vector3(0, 0, -1).applyMatrix4(matrix).sub(camPos).normalize();
                const right = new THREE.Vector3(1, 0, 0).applyMatrix4(matrix).sub(camPos).normalize();
                const up = new THREE.Vector3(0, 1, 0); // Absolute up

                // Handle movement relative to camera direction
                if (keys['w']) camPos.addScaledVector(forward, currentCamSpeed);
                if (keys['s']) camPos.addScaledVector(forward, -currentCamSpeed);
                if (keys['a']) camPos.addScaledVector(right, -currentCamSpeed);
                if (keys['d']) camPos.addScaledVector(right, currentCamSpeed);
                if (keys[' ']) camPos.addScaledVector(up, currentCamSpeed); // Space for up
                if (keys['Control']) camPos.addScaledVector(up, -currentCamSpeed); // Control for down

                // No need to call camera.lookAt() as rotation is set via quaternion/euler
            } else {
                // POV CAMERA MODE (Existing Logic)

                const ballPosition = ballMesh.position;

                // Calculate camera position based on angle and distance
                camera.position.set(
                    ballPosition.x + cameraDistance * Math.sin(cameraAngle),
                    ballPosition.y + cameraHeight,
                    ballPosition.z + cameraDistance * Math.cos(cameraAngle)
                );

                // Reset pitch in POV mode
                cameraPitch = -Math.PI / 8;

                // Calculate the point the camera should look at
                const lookAtX = ballPosition.x + cameraLookAhead * Math.sin(cameraAngle);
                const lookAtZ = ballPosition.z + cameraLookAhead * Math.cos(cameraAngle);
                const lookAtPoint = new THREE.Vector3(lookAtX, ballPosition.y, lookAtZ);

                camera.lookAt(lookAtPoint);
            }
            // --- End Camera Positioning Logic ---

            // Update coordinates display if visible
            if (coordinatesDisplay.style.display === 'block') {
                const displayPos = isFreeCamera ? camera.position : ballMesh.position;
                coordXSpan.textContent = displayPos.x.toFixed(2);
                coordYSpan.textContent = displayPos.y.toFixed(2);
                coordZSpan.textContent = displayPos.z.toFixed(2);
            }

            renderer.render(scene, camera);
        }

        // Start the game when the window loads
        window.onload = function() {
            init();
            animate();
        };
    </script>
</body>
</html>
